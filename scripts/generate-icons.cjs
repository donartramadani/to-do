/* eslint-disable no-undef */
/* eslint-disable no-useless-escape */
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable quotes */
/* eslint-disable no-console */
const fs = require('fs');
const path = require('path');
const { optimize } = require('svgo');
const iconsPath = path.join(__dirname, '../src/assets/icons');
const iconComponentPath = path.join(__dirname, '../src/components/Icons/Icon.generated.tsx');
async function run() {
  /**
   *
   * First step, process each individual SVG file
   *
   */
  const icons = [];
  const iconFiles = fs.readdirSync(iconsPath).filter((f) => f[0] !== '.');
  let result = { processed: [], errors: [] };
  for (const i in iconFiles) {
    const iconFileName = iconFiles[i];
    try {
      if (iconFileName.match(/\.svg$/)) {
        const iconFileData = fs.readFileSync(path.resolve(iconsPath, iconFileName));
        let svg;
        try {
          svg = optimize(iconFileData, {
            path: iconFileName,
            plugins: [
              {
                name: 'preset-default',
                params: {
                  overrides: {
                    removeViewBox: false,
                  },
                },
              },
            ],
          });
        } catch (error) {
          throw new Error(`Cannot process SVG content`);
        }
        if (!svg || !svg.data || svg.data.length === 0) {
          throw new Error(`No SVG content`);
        }
        icons.push({
          icon: iconFileName.slice(0, -4),
          filename: iconFileName,
          svg: svg.data
            .replace('class', 'className')
            .replace(/fill-rule/g, 'fillRule')
            .replace(/clip-rule/g, 'clipRule')
            .replace(/clip-path/g, 'clipPath')
            .replace(/xlink:href/g, 'xlinkHref')
            .replace(/sketch:type/g, 'sketchType')
            .replace(/xmlns:xlink/g, 'xmlnsXlink')
            .replace(/fill-opacity/g, 'fillOpacity')
            .replace(/stroke-width/g, 'strokeWidth')
            .replace(/flood-opacity/g, 'floodOpacity')
            .replace(/stroke-linecap/g, 'strokeLinecap')
            .replace(/stroke-linejoin/g, 'strokeLinejoin')
            .replace(/stroke-miterlimit/g, 'strokeMiterlimit')
            .replace(/color-interpolation-filters/g, 'colorInterpolationFilters')
            .replace(/fill=\"#([^"]*)\"/g, "fill='currentColor'")
            .replace(/style="mask-type:alpha"/, "style={{maskType:'alpha'}}"),
        });
        result.processed.push(iconFileName);
      }
    } catch (error) {
      result.errors.push(`${iconFileName}: ${error.message}`);
    }
  }

  console.log('generate-icons script completed. Result:', result);

  if (result.errors.length > 0) {
    process.exit(1);
  }
  /**
   *
   * Second step, generate React code
   *
   */
  const iconComponent = [
    `//\n`,
    `// WARNING\n`,
    `//\n`,
    `// Do not make manual changes to this file.\n`,
    `// This file was generated by generate-icons.js.\n`,
    `//\n`,
    `//\n`,
    `\n\n`,
    `/**\n`,
    ` * A list of all available icons in the icon set.\n`,
    ` */\n`,
    'export type IconDefinition = ',
    icons.map((i) => `'${i.icon}'`).join(' | '),
    `;\n\n`,
    `export const availableIcons: IconDefinition[] = [`,
    icons.map((i) => `'${i.icon}'`).join(', '),
    `];\n\n`,
    `export const IconSvg = {\n`,
    icons.map((i) => `  '${i.icon}': ${i.svg},\n`).join(''),
    `};\n`,
  ];
  fs.writeFileSync(iconComponentPath, iconComponent.join(''));
}
run();
